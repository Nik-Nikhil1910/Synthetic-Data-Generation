"""
Generated Code Validators
=========================

This module validates Python code generated by faker_generator.py.
It performs syntax and execution validation on the OUTPUT code,
NOT the input plan.

Validation is execution-based:
1. Syntax check via ast.parse()
2. Runtime execution in sandbox
3. Verification of data_store state
"""

import ast
from typing import Any
from dataclasses import dataclass


# =============================================================================
# EXCEPTIONS
# =============================================================================

class CodeValidationError(Exception):
    """Raised when generated code fails validation."""
    pass


class SyntaxValidationError(CodeValidationError):
    """Raised when generated code has syntax errors."""
    pass


class ExecutionValidationError(CodeValidationError):
    """Raised when generated code fails at runtime."""
    pass


# =============================================================================
# DATA STRUCTURES
# =============================================================================

@dataclass
class ExecutionResult:
    """Result of executing generated code."""
    success: bool
    data_store: dict[str, list[dict]]
    error_message: str | None = None
    
    @property
    def table_count(self) -> int:
        """Get number of tables in data_store."""
        return len(self.data_store)
    
    def get_row_count(self, table_name: str) -> int:
        """Get row count for a specific table."""
        return len(self.data_store.get(table_name, []))


# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

def validate_syntax(code: str) -> bool:
    """
    Validate Python syntax of generated code.
    
    Args:
        code: Python source code string.
        
    Returns:
        True if syntax is valid.
        
    Raises:
        SyntaxValidationError: If code has syntax errors.
    """
    if not code or not code.strip():
        raise SyntaxValidationError("Generated code is empty.")
    
    try:
        ast.parse(code)
        return True
    except SyntaxError as e:
        raise SyntaxValidationError(
            f"Syntax error at line {e.lineno}: {e.msg}"
        ) from e


def execute_code(code: str) -> ExecutionResult:
    """
    Execute generated code in a sandbox and return the data_store.
    
    Args:
        code: Python source code string.
        
    Returns:
        ExecutionResult with data_store contents.
        
    Raises:
        ExecutionValidationError: If code fails at runtime.
    """
    # First validate syntax
    validate_syntax(code)
    
    # Prepare execution context with required imports available
    exec_globals: dict[str, Any] = {}
    exec_locals: dict[str, Any] = {}
    
    try:
        exec(code, exec_globals, exec_locals)
    except Exception as e:
        raise ExecutionValidationError(
            f"Runtime error: {type(e).__name__}: {e}"
        ) from e
    
    # Extract data_store from executed context
    data_store = exec_locals.get("data_store")
    
    if data_store is None:
        # Check globals as well (exec behavior can vary)
        data_store = exec_globals.get("data_store")
    
    if data_store is None:
        raise ExecutionValidationError(
            "Generated code did not produce a 'data_store' variable."
        )
    
    if not isinstance(data_store, dict):
        raise ExecutionValidationError(
            f"'data_store' must be a dict, got {type(data_store).__name__}."
        )
    
    return ExecutionResult(
        success=True,
        data_store=data_store
    )


def validate_execution_against_plan(
    code: str,
    plan: dict
) -> ExecutionResult:
    """
    Execute code and validate output matches the plan.
    
    Args:
        code: Python source code string.
        plan: Generation Plan JSON used to create the code.
        
    Returns:
        ExecutionResult with validation complete.
        
    Raises:
        ExecutionValidationError: If output doesn't match plan.
    """
    result = execute_code(code)
    
    # Validate all tables exist
    expected_tables = set(plan.get("execution_order", []))
    actual_tables = set(result.data_store.keys())
    
    missing = expected_tables - actual_tables
    if missing:
        raise ExecutionValidationError(
            f"Missing tables in data_store: {sorted(missing)}"
        )
    
    # Validate row counts
    table_specs = {t["name"]: t for t in plan.get("tables", [])}
    
    for table_name in expected_tables:
        expected_rows = table_specs.get(table_name, {}).get("row_count", 0)
        actual_rows = result.get_row_count(table_name)
        
        if actual_rows != expected_rows:
            raise ExecutionValidationError(
                f"Table '{table_name}' has {actual_rows} rows, expected {expected_rows}."
            )
    
    return result
